-----------------------------------------------------------------------Practical 5 ----------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\bubble.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def bubble_sort(unordered_list):
    for r in range(1,len(unordered_list)):
        for i in range(len(unordered_list)-r):
            if unordered_list[i]>unordered_list[i+1]:
                unordered_list[i],unordered_list[i+1] = unordered_list[i+1],unordered_list[i]

input_list = input("Enter the unordered List:")
unordered_list = list(map(int,input_list.split()))
bubble_sort(unordered_list)
print("Sorted List:",unordered_list)                                      




XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\Heap Sort.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

class Heap:
    def __init__(self):
        self.heap = []
        self.size = 0

    def insert(self, value):
        self.heap.append(value)
        self.size += 1
        self._bubble_up(self.size - 1)

    def _bubble_up(self, index):
        parent_index = (index - 1) // 2
        if parent_index >= 0 and self.heap[index] > self.heap[parent_index]:
            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
            self._bubble_up(parent_index)

    def pop(self):
        if self.size == 0:
            raise IndexError("Pop from an empty heap")
        root = self.heap[0]
        self.heap[0] = self.heap[self.size - 1]
        self.size -= 1
        self.heap.pop()
        self._bubble_down(0)
        return root

    def _bubble_down(self, index):
        left_child = 2 * index + 1
        right_child = 2 * index + 2
        largest = index

        if left_child < self.size and self.heap[left_child] > self.heap[largest]:
            largest = left_child

        if right_child < self.size and self.heap[right_child] > self.heap[largest]:
            largest = right_child

        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._bubble_down(largest)

    def heap_sort(self):
        sorted_list = []
        original_size = self.size
        for _ in range(original_size):
            sorted_list.append(self.pop())
        return sorted_list

# Main program
if __name__ == "__main__":
    # Accept input from the user
    unsorted_list = list(map(int, input("Enter numbers separated by spaces: ").split()))

    # Initialize the heap and insert elements
    h = Heap()
    for i in unsorted_list:
        h.insert(i)

    # Print the unsorted list
    print("Unsorted list:", unsorted_list)

    # Perform heap sort
    sorted_list = h.heap_sort()

    # Print the sorted list
    print("Sorted list:", sorted_list)



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\insertion.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def insertion_sort(list1):
    for i in range(1,len(list1)):
        temp = list1[i]

        j = i-1
        while j>=0 and temp<list1[j]:
            list1[j+1] = list1[j]
            j-=1
        list1[j+1] = temp

input_list = input("Enter the unordered List:")
list1 = list(map(int,input_list.split()))
insertion_sort(list1)
print("Sorted List:",list1)


        

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\merge.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def merge_sort(list1):
    if len(list1) > 1:
        mid = len(list1)//2
        leftlist = list1[:mid]
        rightlist = list1[mid:]

        merge_sort(leftlist)
        merge_sort(rightlist)
        i=j=k=0
        while i<len(leftlist) and j<len(rightlist):
            if leftlist[i]<rightlist[j]:
                list1[k]=leftlist[i]
                i+=1
            else:
                list1[k]=rightlist[j]
                j+=1
            k+=1

        while i<len(leftlist):
            list1[k]=leftlist[i]
            i+=1
            k+=1

        while j<len(rightlist):
            list1[k]=rightlist[j]
            j+=1
            k+=1

input_list = input("Enter the unsorted List:")
list1 = list(map(int,input_list.split()))
merge_sort(list1)
print("Sorted List:",list1)  


        
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\quick.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def quick_sort(list1):
    if len(list1)<=1:
        return list1
    else:
        pivot = list1[0]
        lesser = [x for x in list1[1:] if x<=pivot]
        greater = [x for x in list1[1:] if x>pivot]
        return quick_sort(lesser) + [pivot] + quick_sort(greater)
input_list = input("Enter the unordered List:")
list1 = list(map(int,input_list.split()))
sorted_list = quick_sort(list1)
print("Sorted List:",sorted_list)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr5\selection.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def selection_sort(unsorted_list):
    n = len(unsorted_list)
    for i in range(n):
        min_index = i
        for j in range(i+1,n):
            if unsorted_list[j]<unsorted_list[min_index]:
                min_index = j
        unsorted_list[i],unsorted_list[min_index]=unsorted_list[min_index],unsorted_list[i]

input_list = input("Enter the unsorted List:")
unsorted_list = list(map(int,input_list.split()))
selection_sort(unsorted_list)
print("Sorted List:",unsorted_list)  
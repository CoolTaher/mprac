-----------------------------------------------------------------------Practical 10 ----------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr10\Q1 linear probing.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def insert_into_hash_table(hash_table, size, data):
    key = data % size  # Calculate the initial hash index
    for i in range(size):
        new_key = (key + i) % size  # Linear probing: check the next slot
        if hash_table[new_key] is None:
            hash_table[new_key] = data
            print(f"Inserted {data} at index {new_key}")
            return
    # If the loop completes without finding an empty slot
    print(f"Hash table is full! Could not insert {data}.")

def display_hash_table(hash_table):
    print('\nHash Table:')
    for index, value in enumerate(hash_table):
        print(f'Index {index}: {value}')

def main():
    size = int(input("Enter the size of the hash table: "))
    hash_table = [None] * size  # Initialize the hash table with None values
    n = int(input("Enter the number of elements to insert: "))

    if n > size:
        print("Warning: Number of elements exceeds hash table size. Some elements may not be inserted.")

    for _ in range(n):
        data = int(input("Enter data to insert: "))
        insert_into_hash_table(hash_table, size, data)

    display_hash_table(hash_table)

if __name__ == '__main__':
    main()



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr10\Q2 quadratic probing.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def insert_into_hash_table(hash_table, size, data):
    key = data % size  # Calculate the initial hash index
    for i in range(size):
        new_key = (key + i ** 2) % size  # Quadratic probing: check the next slot
        if hash_table[new_key] is None:
            hash_table[new_key] = data
            print(f"Inserted {data} at index {new_key}.")
            return
    # If the loop completes without finding an empty slot
    print(f"Hash table is full! Could not insert {data}.")

def display_hash_table(hash_table):
    print("\nHash Table:")
    for index, value in enumerate(hash_table):
        print(f"Index {index}: {value}")

def main():
    size = int(input("Enter the size of the hash table: "))
    hash_table = [None] * size  # Initialize the hash table with None values
    n = int(input("Enter the number of elements to insert: "))

    if n > size:
        print("Warning: Number of elements exceeds hash table size. Some elements may not be inserted.")

    for _ in range(n):
        data = int(input("Enter data to insert: "))
        insert_into_hash_table(hash_table, size, data)

    display_hash_table(hash_table)

if __name__ == "__main__":
    main()


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr10\Q3 compute hash.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

def compute_hash(s):
    return hash(s)

#access multiple inputs from the user
user_strings = input("Enter words separated by commas : ").split(',')

#strip any whitespace around the words
user_strings = [s.strip() for s in user_strings]

#compute and display hashes
for s in user_strings:
    print(f"The hash for '{s}' is : {compute_hash(s)}")


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[Pr10\Q4 hash func,add,delete.py]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

#Q4
class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [[] for _ in range(size)]
    def _hash_function(self, key):
        return hash(key) % self.size
    def insert(self, key, value):
        hash_index = self._hash_function(key)
        for pair in self.table[hash_index]:
            if pair[0] == key:
                pair[1] = value
                return
        self.table[hash_index].append([key, value])
    def search(self, key):
        hash_index = self._hash_function(key)
        for pair in self.table[hash_index]:
            if pair[0] == key:
                return pair[1]
        return None
    def delete(self, key):
        hash_index = self._hash_function(key)
        for pair in self.table[hash_index]:
            if pair[0] == key:
                self.table[hash_index].remove(pair)
                return True
        return False
hash_table = HashTable(10)
n = int(input("Enter number of key value pairs : "))
for _ in range(n):
    key = input("Enter key : ")
    value = input("Enter value : ")
    hash_table.insert(key, value)

search_key = input("Enter key to search : ")
print(f"Value for '{search_key}' : {hash_table.search(search_key)}")

delete_key = input("Enter key to delete : ")
hash_table.delete(delete_key)
print(f"Value for '{delete_key}' after deletion : {hash_table.search(delete_key)}")


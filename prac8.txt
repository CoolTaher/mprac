
-----------------------------------------------------------------------Practical 8----------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q1.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

'''#Find all eigrn values of matrix(user input)[Q1]
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

A=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[2,4],[5,6]])#for predefined matrix
print("Matrix A:",A)
print("Charcteristic ploynomial of A:",charac_poly(A))
print("Eigenvalues of a with their algebric multiplicity:",eig_vals(A))'''


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q2.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

'''#Q2
#Accept 2x2 matrix and find eigrn values of matrix A+2B
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

A=Matrix(input_mat(square=True,dtype=S))
B=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[2,4],[5,6]])#for predefined matrix
#B=Matrix([[1,3],[2,6]])
print("Matrix A:",A)
print("Matrix B:",B)
result_matrix = A+2*B
print("Matrix A+2B:",result_matrix)
print("Charcteristic ploynomial of A:",charac_poly(result_matrix))
print("Eigenvalues of a with their algebric multiplicity:",eig_vals(result_matrix))'''


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q3.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

'''#Find eigenvalues and eigenvectors[Q3]
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

def eig_vec(mat):
    A_LI = get_A_LI(mat)
    charac = det(A_LI)
    vals = roots(charac)
    vecs = [A_LI.subs('lambda',val).nullspace() for val in vals]
    return vals, vecs

A=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[2,4],[5,6]])#for predefined matrix
print("Matrix A:",A)
print("Charcteristic ploynomial of A:",charac_poly(A))
print("Eigenvalues of a with their algebric multiplicity:",eig_vals(A))
print("Eigenvectors of A with their algebraic and geometric multiplicities and eigenvectors, respectively:",eig_vec(A))'''


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q4.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

'''#Q4
#Find diagonal of a matrix
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

def eig_vec(mat):
    A_LI = get_A_LI(mat)
    charac = det(A_LI)
    vals = roots(charac)
    vecs = [A_LI.subs('lambda',val).nullspace() for val in vals]
    return vals, vecs

def diagonal_mat_from_eigenvals(mat):
    vals = eig_vals(mat)
    diag_mat = eye(len(vals))
    for i, val in enumerate(vals):
        diag_mat[i,i] = val
    return diag_mat

A=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[1,2],[4,3]])#for predefined matrix
print("Matrix A:",A)
diag_mat = diagonal_mat_from_eigenvals(A)
print("Diagonal matrix formed from the eigenvalues of A:", diag_mat)'''



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q5.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


'''#Q5
#Find modal matrix(user input)
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

def eig_vec(mat):
    A_LI = get_A_LI(mat)
    charac = det(A_LI)
    vals = roots(charac)
    vecs = [A_LI.subs('lambda',val).nullspace() for val in vals]
    return vals, vecs

def modal_mat(mat):
    eigenvec = eig_vec(mat)
    return Matrix.hstack(*[v[0] for v in eigenvec])

A=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[1,2],[4,3]])#for predefined matrix
print("Matrix A:",A)
print("Modal matrix (matrix of eigenvectors):", modal_mat(A))'''


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q6.html]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

'''#Q6
#Find diagonnal and modal matrix
from sympy import Symbol, eye, det, Matrix, S, roots

def input_mat(square=False, dtype=float):  #for user input
    if square:
        r=c=int(input("Enter the dimension of square matrix:"))
    else:
        r=int(input("Enter the no.of rows:"))
        c=int(input("Enter the no.of cols:"))

    ret_mat=[]
    for i in range(r):
        ret_row=[dtype(input(f"Enter elements for position [{i+1},{j+1}]:"))for j in range(c)]
        ret_mat.append(ret_row)
    return ret_mat

def get_A_LI(mat,var='lambda'):
    r,c=mat.shape
    L=Symbol(var)
    I=eye(r)

    return mat - L*I

def charac_poly(mat,var='lambda'):
    A_LI = get_A_LI(mat,var=var)

    return det(A_LI).as_poly().monic()

def eig_vals(mat):
    charac = charac_poly(mat)
    return roots(charac)

def eig_vec(mat):
    A_LI = get_A_LI(mat)
    charac = det(A_LI)
    vals = roots(charac)
    vecs = [A_LI.subs('lambda',val).nullspace() for val in vals]
    return vals, vecs

def diagonal_mat_from_eigenvals(mat):
    vals = eig_vals(mat)
    diag_mat = eye(len(vals))
    for i, val in enumerate(vals):
        diag_mat[i,i] = val
    return diag_mat

def modal_mat(mat):
    eigenvec = eig_vec(mat)
    return Matrix.hstack(*[v[0] for v in eigenvec])

A=Matrix(input_mat(square=True,dtype=S))
#A=Matrix([[1,2],[4,3]])#for predefined matrix
print("Matrix A:",A)
diag_mat = diagonal_mat_from_eigenvals(A)
print("Diagonal matrix formed from the eigenvalues of A:", diag_mat)
print("Modal matrix (matrix of eigenvectors):", modal_mat(A))'''
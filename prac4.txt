
-----------------------------------------------------------------------Practical 4----------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Ramdom]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#Take user input matrix and convert it into row echelon form
import numpy as np
'''from math import isclose

def input_mat(square=False, dtype=float):
    if square:
        r = c = int(input("Enter dimension of square matrix: "))
    else:
        r = int(input("Enter the number of rows: "))
        c = int(input("Enter the number of columns: "))

    ret_mat = []
    for i in range(r):
        ret_row = [dtype(input(f"Enter the element for position [{i+1},{j+1}]: ")) for j in range(c)]
        ret_mat.append(ret_row)

    return ret_mat

def echelon_form(mat, pivot=False):
    mat = np.array(mat, dtype=float)
    r, c = mat.shape
    pivot_set = set()
    shift = 0

    for i in range(min(r, c)):
        while i + shift < c and all(isclose(elem, 0, abs_tol=1e-08) for elem in mat[i:, i + shift]):
            shift += 1
            if i + shift == c:
                break

        if i + shift == c:  # Break out of the main loop if we're done with all columns
            break

        pivot = mat[i, i + shift]
        for next_row in range(i + 1, r):
            below_pivot = mat[next_row, i + shift]
            if not isclose(below_pivot, 0, abs_tol=1e-08):
                if not isclose(pivot, 0, abs_tol=1e-08):
                    mat[next_row] -= (below_pivot / pivot) * mat[i]
                else:
                    mat[[i, next_row]] = mat[[next_row, i]]  # Swap rows
                    pivot = below_pivot

        pivot_set.add(i + shift)
        mat[i + 1:, i + shift] = 0

    if pivot:
        return mat, pivot_set
    return mat

# Input matrix from user
A = input_mat()
echelon_matrix = echelon_form(A)

print("Echelon form of A:\n", echelon_matrix)'''

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q1,2,3,4]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#for echelon form
'''import numpy as np

def input_matrix():
    rows = int(input("Enter the number of rows: "))
    cols = int(input("Enter the number of columns: "))
    
    matrix = []
    for i in range(rows):
        row = []
        for j in range(cols):
            val = float(input(f"Enter element [{i+1},{j+1}]: "))
            row.append(val)
        matrix.append(row)
    
    return np.array(matrix)

def row_echelon_form(matrix):
    mat = matrix.astype(float)
    rows, cols = mat.shape

    for i in range(min(rows, cols)):
        # Find the pivot row and swap it to the top if necessary
        pivot_row = i + np.argmax(np.abs(mat[i:, i]))
        if mat[pivot_row, i] == 0:
            continue  # Skip if the pivot is zero
        
        if pivot_row != i:
            mat[[i, pivot_row]] = mat[[pivot_row, i]]  # Swap rows

        # Normalize the pivot row
        mat[i] = mat[i] / mat[i, i]

        # Eliminate rows below the pivot
        for j in range(i + 1, rows):
            mat[j] = mat[j] - mat[j, i] * mat[i]
    
    return mat



def main():
    matrix = input_matrix()
    print("\nInput matrix:")
    print(matrix)
    
    echelon_matrix = row_echelon_form(matrix)
    print("\nRow Echelon Form:")
    print(echelon_matrix)

if __name__ == "__main__":
    main()'''


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[Q5,6,7,8]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


'''#take user input mat and find it's rank[Q5,6,7,8]
import numpy as np

def input_matrix():
    rows = int(input("Enter the number of rows: "))
    cols = int(input("Enter the number of columns: "))
    
    matrix = []
    for i in range(rows):
        row = []
        for j in range(cols):
            val = float(input(f"Enter element [{i+1},{j+1}]: "))
            row.append(val)
        matrix.append(row)
    
    return np.array(matrix)

def row_echelon_form(matrix):
    mat = matrix.astype(float)
    rows, cols = mat.shape

    for i in range(min(rows, cols)):
        # Find the pivot row and swap it to the top if necessary
        pivot_row = i + np.argmax(np.abs(mat[i:, i]))
        if mat[pivot_row, i] == 0:
            continue  # Skip if the pivot is zero
        
        if pivot_row != i:
            mat[[i, pivot_row]] = mat[[pivot_row, i]]  # Swap rows

        # Normalize the pivot row
        mat[i] = mat[i] / mat[i, i]

        # Eliminate rows below the pivot
        for j in range(i + 1, rows):
            mat[j] = mat[j] - mat[j, i] * mat[i]
    
    return mat

def matrix_rank(matrix):
    # Row echelon form of the matrix
    echelon_matrix = row_echelon_form(matrix)
    rank = 0

    # Count the number of non-zero rows in the row echelon form
    for row in echelon_matrix:
        if not np.allclose(row, 0):  # Check if the row is not entirely zeros
            rank += 1

    return rank

def main():
    matrix = input_matrix()
    print("\nInput matrix:")
    print(matrix)

    echelon_matrix = row_echelon_form(matrix)
    print("\nRow Echelon Form:")
    print(echelon_matrix)

    rank = matrix_rank(matrix)
    print(f"\nRank of the matrix: {rank}")

if __name__ == "__main__":
    main()'''

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[[All Q]]xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#predefined mat and  and echelon form find it's rank[All Q]
import numpy as np

matrix = np.array([[3,2,4],[1,5,3],[1,3,2]],dtype=float)#provide matrix accordingly 

def row_echelon_form(matrix):
    mat = matrix.astype(float)
    rows, cols = mat.shape

    for i in range(min(rows, cols)):
        # Find the pivot row and swap it to the top if necessary
        pivot_row = i + np.argmax(np.abs(mat[i:, i]))
        if mat[pivot_row, i] == 0:
            continue  # Skip if the pivot is zero
        
        if pivot_row != i:
            mat[[i, pivot_row]] = mat[[pivot_row, i]]  # Swap rows

        # Normalize the pivot row
        mat[i] = mat[i] / mat[i, i]

        # Eliminate rows below the pivot
        for j in range(i + 1, rows):
            mat[j] = mat[j] - mat[j, i] * mat[i]
    
    return mat

def matrix_rank(matrix):
    # Row echelon form of the matrix
    echelon_matrix = row_echelon_form(matrix)
    rank = 0

    # Count the number of non-zero rows in the row echelon form
    for row in echelon_matrix:
        if not np.allclose(row, 0):  # Check if the row is not entirely zeros
            rank += 1

    return rank

def main():
    print("\nInput matrix:")
    print(matrix)

    echelon_matrix = row_echelon_form(matrix)
    print("\nRow Echelon Form:")
    print(echelon_matrix)

    rank = matrix_rank(matrix)
    print(f"\nRank of the matrix: {rank}")

if __name__ == "__main__":
    main()